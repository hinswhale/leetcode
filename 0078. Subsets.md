* 0078 - Subsets
* 难度：Medium｜ 中等
* 相关知识点：`Array` | `Backtracking` | `Bit Manipulation`
* 题目链接：[https://leetcode.com/problems/subsets/description/](https://leetcode.com/problems/subsets/description/)


```Given an integer array nums of unique elements, return all possible 
subsets
 (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

 

Example 1:

Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:

Input: nums = [0]
Output: [[],[0]]
 

Constraints:

1 <= nums.length <= 10
-10 <= nums[i] <= 10
All the numbers of nums are unique.
```

## Solution 1 回溯算法
### 1.1
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = [[],]
        l = len(nums)
        ans = []
        def backtracking(index, l):
            if len(ans) == l:
                result.append(ans[:])
                return

            for i in range(index, len(nums)):
                ans.append(nums[i])
                backtracking(i+1, l)
                ans.pop()
        
        for i in range(1, l+1):
            backtracking(0, i)
        return result
```
### 1.2 简化版
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        def backtracking(index, ans):
            result.append(ans)
            for i in range(index, len(nums)):
                backtracking(i+1, ans+[nums[i]])
        
        backtracking(0, [])
        return result

```
时间复杂度：时间复杂度为 O(2^N)，其中 N 是数组的长度。
空间复杂度为 O(N)

### Solution 2 迭代

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = [[]]
        
        for num in nums:
            result += [item + [num] for item in result]
        return result

```
Time complexity: O(2^n)
Space complexity：

解析：
1. result = [[]]
2. num=1, result = [[], [1]]
3. num=2, result = [[], [1], []+[2], [1]+[2]]
4. num=3, result =  [[], [1], [2], [1,2], [3], [1,3], [2, 3], [1,2,3]]

### Solution 3 Bit Manipulation
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        result = []
        
        for i in range(1 << n):
            subset = [nums[j] for j in range(n) if (i & (1 << j)) > 0]
            result.append(subset)

        return result
```

解析：
1 << n 表示左移 n 位，即 2^n。这是因为每个元素在子集中有两种状态，选中或不选中，所以总共有 2^n 个可能的组合。

对于每一个生成的数字 i，内层循环通过 (i & (1 << j)) > 0 来检查第 j 位是否为 1。如果是，说明选择了对应的元素 nums[j]，将其加入到当前子集中。

这样，通过遍历所有的二进制数，我们可以生成包含所有可能子集的列表。

举例说明：

假设数组 nums = [1, 2, 3]，对应的二进制数范围是 [0, 7]（二进制 000 到 111）。

当 i = 0 时，二进制 000，对应子集 []；
当 i = 1 时，二进制 001，对应子集 [3]；
当 i = 2 时，二进制 010，对应子集 [2]；
...
当 i = 7 时，二进制 111，对应子集 [1, 2, 3]。
